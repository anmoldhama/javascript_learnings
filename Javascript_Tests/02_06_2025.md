✅ Section 1: Asynchronous & Event Loop (10 Questions)
Q) Explain how the Node.js event loop works and its phases.

Q) What is the difference between process.nextTick() and setImmediate()?

Q) How does Node handle blocking operations in the event loop?

Q) What are microtasks and macrotasks in Node.js?

Q) What happens when an async function throws an uncaught error?

Q) Can you explain the impact of a long-running synchronous function on the event loop?

Q) How does async_hooks work in Node.js? What are its use cases?

Q) What is a "zombie process" in Node.js, and how can it occur?

Q) Explain how to defer function execution using setImmediate() vs setTimeout() with 0 delay.

Q) How can you detect and monitor event loop lag in a production Node.js application?

✅ Section 2: Streams & Buffers (7 Questions)
Q) Explain the concept of backpressure in streams.

Q) How do readable and writable streams work internally in Node.js?

Q) What is the difference between fs.readFile() and fs.createReadStream()?

Q) How would you implement a custom stream in Node.js?

Q) What are the types of streams available in Node.js?

Q) How can you convert a stream to a buffer and vice versa?

Q) Explain how to pipeline multiple streams and handle errors properly.

✅ Section 3: Cluster, Worker Threads & Performance (8 Questions)
Q) What is the difference between the cluster module and worker_threads?

Q) When would you use worker threads instead of clustering?

Q) How do you share memory between worker threads in Node.js?

Q) How can Node.js be scaled horizontally across CPU cores?

Q) How would you benchmark and profile a Node.js application?

Q) How does load balancing work with the cluster module?

Q) What is thread pool exhaustion, and how can you detect/prevent it?

Q) How can you optimize a Node.js app for low latency and high throughput?

✅ Section 4: Architecture & Design (7 Questions)
Q) What architectural patterns are commonly used in large Node.js applications?

Q) How do you implement graceful shutdown in Node.js?

Q) What are the best practices for structuring a Node.js backend project?

Q) How do you handle circular dependencies in a Node.js project?

Q) Explain the concept of a service layer in Node.js and why it matters.

Q) What is dependency injection, and how can you implement it in Node.js?

Q) How do you implement a plugin system in a Node.js app?

✅ Section 5: Error Handling & Debugging (5 Questions)
Q) How do you handle uncaught exceptions and unhandled promise rejections?

Q) How do you prevent memory leaks in a long-running Node.js server?

Q) What tools do you use to debug a Node.js application in production?

Q) What is the difference between try/catch and .catch() for async functions?

Q) How do you monitor and handle application crashes or high memory usage?

✅ Section 6: Security (5 Questions)
Q) How do you prevent prototype pollution in a Node.js application?

Q) What is the impact of using eval() or Function() in Node.js?

Q) How do you securely handle environment variables and secrets?

Q) What are common security headers you should implement in a Node.js app?

Q) How would you protect a Node.js app from denial-of-service attacks?

✅ Section 7: Modules, ES6, Tooling (5 Questions)
Q) What are the differences between CommonJS and ES Modules in Node.js?

Q) How does tree shaking work with ES Modules in Node.js?

Q) What are the advantages of using ts-node or transpiling TypeScript in Node apps?

Q) How do you manage module caching in Node.js?

Q) Explain the difference between require.resolve and require.main.

✅ Section 8: Real-World Scenarios & Miscellaneous (5 Questions)
Q) How would you handle retries and exponential backoff for failed API calls in Node.js?

Q) What strategies would you use for rate-limiting in a Node.js API?

Q) How would you implement a job queue in Node.js with reliability guarantees?
