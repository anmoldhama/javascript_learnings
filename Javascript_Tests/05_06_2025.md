✅ Section 1: V8 Engine & JavaScript Runtime (10 Questions)
Q) How does Node.js leverage the V8 engine to execute JavaScript code?

Q) What is Just-In-Time (JIT) compilation in V8 and how does it affect Node.js performance?

Q) What are hidden classes in V8 and how can they lead to performance optimizations or de-optimizations?

Q) How does V8’s garbage collector work (Scavenge vs Mark-and-Sweep vs Incremental)?

Q) How does Node.js handle memory allocation for JavaScript objects under the hood?

Q) What is the generational heap model used by V8, and how does it impact memory usage in Node.js?

Q) What is inline caching, and how does it help speed up repeated property access in Node.js?

Q) How does V8 optimize tail-call recursion, and is it enabled in Node.js?

Q) What happens internally when you use Function.prototype.bind() in V8 and Node.js?

Q) How does V8 optimize array types and how can you unintentionally cause de-optimization in Node.js?

✅ Section 2: Libuv & Event Loop Internals (10 Questions)
Q) How does libuv abstract the OS I/O models (epoll, kqueue, IOCP) for Node.js?

Q) What are the core responsibilities of libuv in a Node.js application?

Q) How does the Node.js event loop differ from the browser event loop?

Q) What are the different phases of the Node.js event loop and their order of execution?

Q) What is the difference between setImmediate, setTimeout, and process.nextTick internally?

Q) How does libuv manage its internal thread pool and what tasks go into it?

Q) What happens when an asynchronous function hits the libuv thread pool limit?

Q) How does Node.js prioritize I/O callbacks versus timers and microtasks?

Q) What are the effects of a blocked event loop and how does Node.js detect it?

Q) How does the uv_run() function control the Node.js execution cycle?

✅ Section 3: Node.js Module System (8 Questions)
Q) How does Node.js internally resolve modules using the CommonJS require() system?

Q) What is the role of the Module._cache and how does module caching work internally?

Q) How is circular dependency handled internally in the Node.js module loader?

Q) What are the internal steps taken when require('fs') is executed?

Q) How does the Node.js loader differ between ESM and CommonJS modules?

Q) What is the role of the package.json "exports" and "imports" field in module resolution?

Q) How are built-in modules like http, fs, etc., bootstrapped into the runtime?

Q) How does the vm module allow execution of code in isolated contexts internally?

✅ Section 4: Streams, Buffers, and Binary Handling (8 Questions)
Q) What is the internal mechanism behind Buffer.alloc() and how is memory allocated?

Q) How does Node.js prevent Buffer overflows and memory corruption?

Q) How does Node.js manage chunk flow control and backpressure in streams?

Q) What is the internal lifecycle of a Readable stream and how does it emit events?

Q) How does the _read() method interact with the internal buffer queue?

Q) How does piping between streams avoid memory pressure internally?

Q) How does Transform stream use internal queues to transform data?

Q) What are slab allocations in Node.js and how are they used in buffer pooling?

✅ Section 5: Async Hooks, Domains & Execution Context (7 Questions)
Q) How does the async_hooks module trace asynchronous context internally in Node.js?

Q) How does the async resource lifecycle work (init, before, after, destroy)?

Q) What are the use cases for executionAsyncId and triggerAsyncId?

Q) How does context propagation work across async boundaries in Node.js?

Q) Why was the domain module deprecated and what were its internal flaws?

Q) How do tools like OpenTelemetry use async_hooks for distributed tracing?

Q) How does Node.js internally track call stacks across asynchronous executions?

✅ Section 6: Native Bindings, C++ Internals, and System Calls (7 Questions)
Q) How are Node.js built-in modules implemented in C++ and exposed to JavaScript?

Q) What is NAN (Native Abstractions for Node.js), and how does it help create native addons?

Q) What is the role of the V8 API in exposing native bindings to JavaScript?

Q) How does Node.js communicate with the operating system for low-level file I/O?

Q) What is the lifecycle of a Node.js native extension (.node file)?

Q) How are file descriptors managed and reused internally in Node.js?

Q) How does Node.js handle signals (like SIGINT, SIGTERM) and pass them to the runtime?