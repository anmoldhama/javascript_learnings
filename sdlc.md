1. Planning
Objective: Define the scope, objectives, feasibility, cost, and timeline.

Key Activities:

Feasibility study (technical, operational, financial)

Resource planning

Risk assessment

Deliverables:

Project plan

Cost-benefit analysis

Risk management plan

üìã 2. Requirements Analysis
Objective: Gather detailed functional and non-functional requirements.

Key Activities:

Stakeholder interviews

Use case analysis

Requirement documentation

Deliverables:

Software Requirement Specification (SRS)

Use case diagrams

Functional requirements list

üèóÔ∏è 3. Design
Objective: Convert requirements into technical architecture and design.

Key Activities:

High-Level Design (HLD): system architecture, technology stack, database design

Low-Level Design (LLD): class diagrams, method signatures, component design

Deliverables:

Design Document Specification (DDS)

Architecture diagrams

UI/UX mockups

üíª 4. Implementation (Development)
Objective: Develop the actual source code based on design documents.

Key Activities:

Code development using chosen programming languages and frameworks

Code reviews

Version control and integration

Deliverables:

Source code

Unit test cases

Build scripts

üß™ 5. Testing
Objective: Ensure the product meets quality standards and requirements.

Key Activities:

Unit testing, Integration testing

System testing, Regression testing

Bug fixing and validation

Deliverables:

Test plan and test cases

Bug reports

Test summary report

üöÄ 6. Deployment
Objective: Release the product to the production environment.

Key Activities:

Release management

Environment setup

Deployment scripts and CI/CD pipelines

Deliverables:

Deployed application

Deployment documentation

Rollback and monitoring setup

üîß 7. Maintenance
Objective: Keep the system operational and enhance it as needed.

Key Activities:

Bug fixes

Performance improvements

Adding new features

Deliverables:

Updated documentation

Patch releases

Support tickets/resolution logs

üîÅ Flow Types (SDLC Models)
Waterfall: Sequential, no overlapping.

Iterative: Repeatable cycles, often feedback-driven.

Agile: Incremental, collaborative, fast iterations.

V-Model: Verification and Validation model.

Spiral: Risk-driven iterative model.





#  Water fall model

+------------------------------+
|          Requirements        |
|------------------------------|
| - Collect all requirements   |
| - Document in SRS            |
| - Review with stakeholders   |
+------------------------------+
|           Design             |
|------------------------------|
| - High-Level Design (HLD)    |
| - Low-Level Design (LLD)     |
| - Define data & architecture |
+------------------------------+
|        Implementation        |
|------------------------------|
| - Write actual code          |
| - Based on design documents  |
| - Follow coding standards    |
+------------------------------+
|           Testing            |
|------------------------------|
| - Verify each module         |
| - Integration testing        |
| - System and UAT testing     |
+------------------------------+
|         Deployment           |
|------------------------------|
| - Release to production      |
| - Configure environment      |
| - Deliver to end users       |
+------------------------------+
|         Maintenance          |
|------------------------------|
| - Post-deployment fixes      |
| - Enhancements or changes    |
| - Monitor system usage       |
+------------------------------+


# | **Pros**                                                      | **Cons**                                                                                                  |
| ------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------- |
| 1. Simple and easy to understand and manage.                  | 1. Very rigid; hard to go back to previous phases once completed.                                         |
| 2. Well-defined stages and milestones.                        | 2. Poor flexibility to accommodate changes during the development process.                                |
| 3. Clear documentation at every phase.                        | 3. Late testing phase means bugs may be found late, making them costly to fix.                            |
| 4. Works well for projects with fixed requirements and scope. | 4. Not suitable for complex, long, or evolving projects where requirements change often.                  |
| 5. Easy to measure progress by milestones.                    | 5. Client involvement is minimal after the requirements phase, risking mismatch with client expectations. |
| 6. Useful for projects where technology is well understood.   | 6. Risk of misunderstanding requirements early can cause failure.                                         |





 # Agile Model Explanation:
Agile is an iterative and incremental software development approach that emphasizes flexibility, customer collaboration, and rapid delivery of small, functional parts of the software. It breaks down the project into small cycles called sprints (usually 1-4 weeks), where a potentially shippable product increment is delivered at the end of each sprint.

Agile encourages continuous feedback, adaptive planning, and quick response to change, making it ideal for projects where requirements evolve or are unclear upfront.

Agile Model - Pros and Cons


| **Pros**                                                    
                                                                         **Cons**     |
| --------------------------------------------------------- | ------------------------------------------------------------------------------------- |
| 1. Highly flexible and adaptable to changes.              | 1. Less predictability in terms of scope, budget, and timeline.                       |
| 2. Customer involvement throughout the process.           | 2. Requires frequent client interaction, which may be difficult in some cases.        |
| 3. Early and continuous delivery of valuable software.    | 3. Can lead to scope creep if changes are not managed properly.                       |
| 4. Encourages teamwork, collaboration, and communication. | 4. Less emphasis on documentation may cause issues in knowledge transfer.             |
| 5. Frequent testing helps catch defects early.            | 5. Requires experienced team members and good project management.                     |
| 6. Better risk management due to iterative approach.      | 6. May not be suitable for very small or very large projects with fixed requirements. |



